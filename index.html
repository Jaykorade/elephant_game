</div> <script> // Config const TILE = 20; const GRID_W = 32, GRID_H = 24; // 640x480 const INIT_FPS = 8; const SPEED_INCREMENT = 2; const DIFFICULTY_INTERVAL_MS = 120_000; // 2 minutes const MAX_OBSTACLES = 30; const LEVEL_THRESHOLDS = [5, 10, 18, 28, 40, 55, 73, milestones // Colors (match CSS) const COLORS = { bg: "#1c1c1c", grid: "#262626", eleBody: "#aaaac8", eleHead: "#c8c8ff", eleDetail: "#9696be", eye: "#1e1e32", peanut: "#dcb43c", obstacle: "#783c3c", text: "#e6e6e6", }; // Helpers const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min; const key = (x, y) => `${x},${y}`; const unkey = (s) => s.split(",").map(Number); function drawGrid(ctx, w, h) { ctx.strokeStyle = COLORS.grid; ctx.lineWidth = 1; for (let x = 0; x <= w; x += TILE) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke(); } for (let y = 0; y <= h; y += TILE) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke(); } } function cellToPx(x, y) { return [x * TILE, y * TILE]; } function randomEmpty(occupied, avoidBorder = false) { const x0 = avoidBorder ? 1 : 0; const x1 = GRID_W - (avoidBorder ? 1 : 0); const y0 = avoidBorder ? 1 : 0; const y1 = GRID_H - (avoidBorder ? 1 : 0); const tries = 500; for (let i = 0; i < tries; i++) { const x = randInt(x0, x1 - 1); const y = randInt(y0, y1 - 1); if (!occupied.has(key(x, y))) return [x, y]; } // Fallback: scan for (let y = y0; y < y1; y++) { for (let x = x0; x < x1; x++) { if (!occupied.has(key(x, y))) return [x, y]; } } return null; } function drawElephant(ctx, x, y, isHead = false, dir = ) { const [px, py] = cellToPx(x, y); const r = 6; // Body rectangle ctx.fillStyle = isHead ? COLORS.eleHead : COLORS.eleBody; ctx.beginPath(); roundRect(ctx, px+2, py+2, TILE-4, TILE-4, r); ctx.fill(); // Head features const cx = px + TILE/2; const cy = py + TILE/2; const [dx, dy] = dir; if (isHead) { // Eye const ex = cx + dx * (TILE/4); const ey = cy + dy * (TILE/4); ctx.fillStyle = COLORS.eye; ctx.beginPath(); ctx.arc(ex, ey, Math.max(2, TILE/8), 0, Math.PI*2); ctx.fill(); // Trunk ctx.strokeStyle = COLORS.eleDetail; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(cx + dx * (TILE/2), cy + dy * (TILE/2)); ctx.stroke(); // Ears ctx.fillStyle = COLORS.eleDetail; const ear = Math.max(3, TILE/4); if (dx !== 0) { circle(ctx, cx, cy - TILE/4, ear); circle(ctx, cx, cy + TILE/4, ear); } else { circle(ctx, cx - TILE/4, cy, ear); circle(ctx, cx + TILE/4, cy, ear); } } else { // Tail nub ctx.fillStyle = COLORS.eleDetail; circle(ctx, cx, cy, Math.max(2, TILE/10)); } } function drawObstacle(ctx, x, y) { const [px, py] = cellToPx(x, y); ctx.fillStyle = COLORS.obstacle; roundRect(ctx, px+2, py+2, TILE-4, TILE-4, 4); ctx.fill(); } function drawPeanut(ctx, x, y) { const [px, py] = cellToPx(x, y); const r = TILE/3; ctx.fillStyle = COLORS.peanut; circle(ctx, px + TILE/2 - r/2, py + TILE/2, r); circle(ctx, px + TILE/2 + r/2, py + TILE/2, r); } function circle(ctx, x, y, r) { ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill(); } function roundRect(ctx, x, y, w, h, r) { const rr = Math.min(r, w/2, h/2); ctx.beginPath(); ctx.moveTo(x+rr, y); ctx.arcTo(x+w, y, x+w, y+h, rr); ctx.arcTo(x+w, y+h, x, y+h, rr); ctx.arcTo(x, y+h, x, y, rr); ctx.arcTo(x, y, x+w, y, rr); ctx.closePath(); } // Game classes class ElephantChain { constructor() { const mid = [Math.floor(GRID_W/2), Math.floor(GRID_H/2)]; this.body = [ [mid, mid], [mid-1, mid], [mid-2, mid], ]; this.dir = ; this.pending = 0; this.alive = true; this.changedThisTick = false; } setDir(newDir) { if (this.changedThisTick) return; const [dx, dy] = this.dir; const [nx, ny] = newDir; // prevent reversing into self if (this.body.length > 1 && dx === -nx && dy === -ny) return; if (dx !== nx || dy !== ny) { this.dir = [nx, ny]; this.changedThisTick = true; } } step(obstacles, wrap=false) { if (!this.alive) return; const head = this.body; let nx = head + this.dir; let ny = head + this.dir; if (wrap) { nx = (nx + GRID_W) % GRID_W; ny = (ny + GRID_H) % GRID_H; } else { if (nx < 0 || nx >= GRID_W || ny < 0 || ny >= GRID_H) { this.alive = false; return; } } const newHead = [nx, ny]; // self collision if (this.body.some(([x,y]) => x===newHead && y===newHead)) { this.alive = false; return; } // obstacle collision if (obstacles.has(key(nx, ny))) { this.alive = false; return; } this.body.unshift(newHead); if (this.pending > 0) this.pending--; else this.body.pop(); this.changedThisTick = false; } grow(n=1) { this.pending += n; } draw(ctx) { for (let i=0; i<this.body.length; i++) { const [x,y] = this.body[i]; drawElephant(ctx, x, y, i===0, this.dir); } } } // Game state const canvas = document.getElementById("game"); const ctx = canvas.getContext("2d"); const scoreEl = document.getElementById("scoreEl"); const levelEl = document.getElementById("levelEl"); const speedEl = document.getElementById("speedEl"); const wrapEl = document.getElementById("wrapEl"); const startBtn = document.getElementById("startBtn"); const pauseBtn = document.getElementById("pauseBtn"); const restartBtn = document.getElementById("restartBtn"); let chain, obstacles, peanut, score, level, fps, wrapMode; let running = false; let paused = false; // Difficulty timing let startTime = 0; let nextDiffTime = 0; let difficultySteps = 0; function occupiedSet() { const occ = new Set(); chain.body.forEach(([x,y]) => occ.add(key(x,y))); obstacles.forEach(k => occ.add(k)); return occ; } function computeLevel(score) { let lv = 1; for (const t of LEVEL_THRESHOLDS) if (score >= t) lv++; return lv; } function buildObstacles(count, border=false) { const set = new Set(); if (border) { for (let x=0;x<GRID_W;x++){ set.add(key(x,0)); set.add(key(x,GRID_H-1)); } for (let y=0;y<GRID_H;y++){ set.add(key(0,y)); set.add(key(GRID_W-1,y)); } } // random interior const occ = new Set(); chain.body.forEach(([x,y]) => occ.add(key(x,y))); let tries = 0; while (set.size < count + (border? (GRID_W+GRID_H)*2 - 4 : 0) && tries < 2000) { tries++; const cell = randomEmpty(occ, false); if (!cell) break; const k = key(cell, cell); if (!set.has(k) && !occ.has(k)) set.add(k); } // Remove any accidental snake overlaps chain.body.forEach(([x,y]) => set.delete(key(x,y))); return set; } function refreshObstacles() { const border = level >= 3; const interiorTarget = Math.min(MAX_OBSTACLES, (level - 1) * 3 + difficultySteps * 2); const borderCount = border ? ((GRID_W + GRID_H) * 2 - 4) : 0; obstacles = new Set(); // add border if needed if (border) { for (let x=0;x<GRID_W;x++){ obstacles.add(key(x,0)); obstacles.add(key(x,GRID_H-1)); } for (let y=0;y<GRID_H;y++){ obstacles.add(key(0,y)); obstacles.add(key(GRID_W-1,y)); } } // fill interiors const occ = new Set(); chain.body.forEach(([x,y]) => occ.add(key(x,y))); let attempts = 0; while ([...obstacles].filter(k => { const [x,y] = unkey(k); return x>0 && x<GRID_W-1 && y>0 && y<GRID_H-1; }).length < interiorTarget && attempts < 2000) { attempts++; const cell = randomEmpty(new Set([...occ, ...obstacles])); if (!cell) break; obstacles.add(key(cell, cell)); } } function spawnPeanut() { const occ = occupiedSet(); const cell = randomEmpty(occ); peanut = cell ? cell : null; if (!cell) chain.alive = false; // filled up } function setHUD() { scoreEl.textContent = String(score); levelEl.textContent = String(level); speedEl.textContent = String(Math.round(fps)); wrapEl.textContent = wrapMode ? "WRAP" : "WALLS"; } function resetGame() { chain = new ElephantChain(); obstacles = new Set(); peanut = null; score = 0; level = 1; fps = INIT_FPS; wrapMode = false; // difficulty timing startTime = performance.now(); nextDiffTime = startTime + DIFFICULTY_INTERVAL_MS; difficultySteps = 0; refreshObstacles(); spawnPeanut(); setHUD(); } // Game loop timing at variable fps let lastFrame = 0; let acc = 0; function loop(ts) { if (!running) return; if (paused) { requestAnimationFrame(loop); return; } const dt = ts - lastFrame || 0; lastFrame = ts; acc += dt; // difficulty step check if (ts >= nextDiffTime) { nextDiffTime += DIFFICULTY_INTERVAL_MS; difficultySteps++; fps = Math.min(30, fps + SPEED_INCREMENT); if (difficultySteps === 2) wrapMode = true; // after 4 minutes refreshObstacles(); // ensure peanut is valid if (!peanut || obstacles.has(key(peanut, peanut)) || chain.body.some(([x,y]) => x===peanut && y===peanut)) { spawnPeanut(); } setHUD(); } // step when accumulated time exceeds frame time const frameTime = 1000 / fps; while (acc >= frameTime) { acc -= frameTime; tick(); } render(); requestAnimationFrame(loop); } function tick() { if (!chain.alive) return; chain.step(obstacles, wrapMode); // Eat peanut if (chain.alive && peanut && chain.body === peanut && chain.body === peanut) { score += 1; chain.grow(1); spawnPeanut(); // Level progression const newLevel = computeLevel(score); if (newLevel !== level) { level = newLevel; // modest speed bump + difficulty compounding fps = Math.min(35, INIT_FPS + (level - 1) * 1 + difficultySteps * SPEED_INCREMENT); refreshObstacles(); if (!peanut || obstacles.has(key(peanut, peanut)) || chain.body.some(([x,y]) => x===peanut && y===peanut)) { spawnPeanut(); } } setHUD(); } } function render() { // clear ctx.fillStyle = COLORS.bg; ctx.fillRect(0, 0, canvas.width, canvas.height); drawGrid(ctx, canvas.width, canvas.height); // obstacles for (const k of obstacles) { const [x, y] = unkey(k); drawObstacle(ctx, x, y); } // peanut if (peanut) drawPeanut(ctx, peanut, peanut); // elephant chain chain.draw(ctx); if (!chain.alive) { overlayText("Game Over", "Press R to Restart or ESC to Pause/Resume"); } else if (paused) { overlayText("Paused", "Press ESC to Resume"); } } function overlayText(title, subtitle) { ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle = COLORS.text; ctx.font = "bold 42px system-ui, sans-serif"; ctx.textAlign = "center"; ctx.fillText(title, canvas.width/2, canvas.height/2 - 10); ctx.font = "16px system-ui, sans-serif"; ctx.fillText(subtitle, canvas.width/2, canvas.height/2 + 22); } // Controls const DIRS = { ArrowUp: [0,-1], ArrowDown: , ArrowLeft: [-1,0], ArrowRight: , w: [0,-1], s:, a:[-1,0], d:, W: [0,-1], S:, A:[-1,0], D:, }; window.addEventListener("keydown", (e) => { if (DIRS[e.key]) { e.preventDefault(); chain.setDir(DIRS[e.key]); } else if (e.key === "Escape") { e.preventDefault(); paused = !paused; } else if (e.key === "r" || e.key === "R") { e.preventDefault(); resetGame(); } }); startBtn.addEventListener("click", () => { if (!running) { resetGame(); running = true; paused = false; lastFrame = performance.now(); requestAnimationFrame(loop); } else if (paused) { paused = false; } }); pauseBtn.addEventListener("click", () => { if (running) paused = !paused; }); restartBtn.addEventListener("click", () => { resetGame(); if (!running) { running = true; lastFrame = performance.now(); requestAnimationFrame(loop); } }); // Boot in idle state with a preview render (function boot() { resetGame(); paused = true; running = true; lastFrame = performance.now(); requestAnimationFrame(loop); })(); </script> </body> </html>